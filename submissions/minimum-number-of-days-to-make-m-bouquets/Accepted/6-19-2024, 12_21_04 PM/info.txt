{"id":1293780766,"question_id":1605,"lang":"java","lang_name":"Java","time":"2Â days","timestamp":1718817664,"status":10,"status_display":"Accepted","runtime":"22 ms","url":"/submissions/detail/1293780766/","is_pending":"Not Pending","title":"Minimum Number of Days to Make m Bouquets","memory":"58.1 MB","code":"class Solution {\n    public int minDays(int[] bloomDay, int m, int k) {\n        if (bloomDay.length < m*k) {\n            return -1;\n        }\n        // System.out.println(isValid(bloomDay, 1, m, k));\n        // System.out.println(isValid(bloomDay, 2, m, k));\n        // System.out.println(isValid(bloomDay, 3, m, k));\n        // System.out.println(isValid(bloomDay, 4, m, k));\n        // System.out.println(isValid(bloomDay, 11, m, k));\n        // System.out.println(isValid(bloomDay, 12, m, k));\n        // System.out.println(isValid(bloomDay, 13, m, k));\n\n        int min = Integer.MAX_VALUE;\n        int max = 0;\n        for (int num : bloomDay) {\n            min = Math.min(min, num);\n            max = Math.max(max, num);\n        }\n\n        // binary search\n        int left = min, right = max;\n        int minDay = -1;\n        if (isValid(bloomDay, left, m, k)) {\n            return left;\n        }\n        if (isValid(bloomDay, right, m, k)) {\n            minDay = right;\n        }\n        for ( ; left <= right; ) {\n            int day = (left + right) / 2;\n            if (isValid(bloomDay, day, m, k)) {\n                minDay = day;\n                right = day - 1;\n            } else {\n                left = day + 1;\n            }\n        }\n        return minDay;\n        // return backtrace(bloomDay, 0, m, k, 0, 0);\n    }\n    private boolean isValid(int[] bloomDay, int day, int m, int k) {\n        int end = 0;\n        for (int w = 0; w < m; w++) {\n            // System.out.println(\"start: \" + end);\n            end = getNextEnd(bloomDay, day, k, end);\n            // System.out.println(\"end: \" + end);\n            // System.out.println();\n            if (end == -1) {\n                return false;\n            } else {\n                end++;\n            }\n        }\n        return true;\n    }\n    private int getNextEnd(int[] bloomDay, int day, int k, int start) {\n        for (int left = start, right = start; right < bloomDay.length; right++) {\n            if (bloomDay[right] > day) {\n                while (right < bloomDay.length && bloomDay[right] > day) {\n                    right++;\n                }\n                left = right;\n            }\n            if (right < bloomDay.length && right - left == k-1) {\n                return right;\n            }\n        }\n        return -1;\n    }\n    // private int backtrace(int[] bloomDay, int val, int m, int k, int i, int j) {\n    //     if (i == m) {\n    //         return val;\n    //     }\n    //     if (j >= bloomDay.length) {\n    //         return Integer.MAX_VALUE;\n    //     } \n    //     int min = Integer.MAX_VALUE;\n    //     for (int w = j; w <= bloomDay.length - (m-i) * k; w++) {\n    //         int max = bloomDay[w];\n    //         for (int x = 0; x < k; x++) {\n    //             max = Math.max(max, bloomDay[w+x]);\n    //         }\n    //         // System.out.println(\"max[\" + w + \", \" + (w+k) + \"): \" + max);\n    //         min = Math.min(min, backtrace(bloomDay, Math.max(val, max), m, k, i+1, w+k));\n    //     }\n    //     return min;\n    // }\n}","compare_result":"111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111","title_slug":"minimum-number-of-days-to-make-m-bouquets","has_notes":false,"flag_type":1}