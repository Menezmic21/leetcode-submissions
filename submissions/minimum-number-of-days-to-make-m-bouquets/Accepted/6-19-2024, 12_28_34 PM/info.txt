{"id":1293789247,"question_id":1605,"lang":"java","lang_name":"Java","time":"2Â days","timestamp":1718818114,"status":10,"status_display":"Accepted","runtime":"20 ms","url":"/submissions/detail/1293789247/","is_pending":"Not Pending","title":"Minimum Number of Days to Make m Bouquets","memory":"57.8 MB","code":"class Solution {\n    public int minDays(int[] bloomDay, int m, int k) {\n        if (bloomDay.length / k < m) {\n            return -1;\n        }\n        // System.out.println(isValid(bloomDay, 1, m, k));\n        // System.out.println(isValid(bloomDay, 2, m, k));\n        // System.out.println(isValid(bloomDay, 3, m, k));\n        // System.out.println(isValid(bloomDay, 4, m, k));\n        // System.out.println(isValid(bloomDay, 11, m, k));\n        // System.out.println(isValid(bloomDay, 12, m, k));\n        // System.out.println(isValid(bloomDay, 13, m, k));\n\n        int min = Integer.MAX_VALUE;\n        int max = 0;\n        for (int num : bloomDay) {\n            min = Math.min(min, num);\n            max = Math.max(max, num);\n        }\n\n        // binary search\n        int left = min, right = max+1;\n        for ( ; left < right; ) {\n            int day = left + (right - left) / 2;\n            if (isValid(bloomDay, day, m, k)) {\n                right = day;\n            } else {\n                left = day + 1;\n            }\n        }\n        return left;\n        // return backtrace(bloomDay, 0, m, k, 0, 0);\n    }\n    private boolean isValid(int[] bloomDay, int day, int m, int k) {\n        int end = 0;\n        for (int w = 0; w < m; w++) {\n            // System.out.println(\"start: \" + end);\n            end = getNextEnd(bloomDay, day, k, end);\n            // System.out.println(\"end: \" + end);\n            // System.out.println();\n            if (end == -1) {\n                return false;\n            } else {\n                end++;\n            }\n        }\n        return true;\n    }\n    private int getNextEnd(int[] bloomDay, int day, int k, int start) {\n        for (int left = start, right = start; right < bloomDay.length; right++) {\n            if (bloomDay[right] > day) {\n                while (right < bloomDay.length && bloomDay[right] > day) {\n                    right++;\n                }\n                left = right;\n            }\n            if (right < bloomDay.length && right - left == k-1) {\n                return right;\n            }\n        }\n        return -1;\n    }\n    // private int backtrace(int[] bloomDay, int val, int m, int k, int i, int j) {\n    //     if (i == m) {\n    //         return val;\n    //     }\n    //     if (j >= bloomDay.length) {\n    //         return Integer.MAX_VALUE;\n    //     } \n    //     int min = Integer.MAX_VALUE;\n    //     for (int w = j; w <= bloomDay.length - (m-i) * k; w++) {\n    //         int max = bloomDay[w];\n    //         for (int x = 0; x < k; x++) {\n    //             max = Math.max(max, bloomDay[w+x]);\n    //         }\n    //         // System.out.println(\"max[\" + w + \", \" + (w+k) + \"): \" + max);\n    //         min = Math.min(min, backtrace(bloomDay, Math.max(val, max), m, k, i+1, w+k));\n    //     }\n    //     return min;\n    // }\n}","compare_result":"111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111","title_slug":"minimum-number-of-days-to-make-m-bouquets","has_notes":false,"flag_type":1}