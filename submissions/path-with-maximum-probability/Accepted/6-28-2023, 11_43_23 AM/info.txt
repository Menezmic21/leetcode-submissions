{"id":981741653,"question_id":1325,"lang":"java","lang_name":"Java","time":"11 months, 4 weeks","timestamp":1687970603,"status":10,"status_display":"Accepted","runtime":"70 ms","url":"/submissions/detail/981741653/","is_pending":"Not Pending","title":"Path with Maximum Probability","memory":"58 MB","code":"class Solution {\n    public double maxProbability(int n, int[][] edges, double[] succProb, int start, int end) {\n        HashMap<Integer, ArrayList<double[]>> neighbors = new HashMap<Integer, ArrayList<double[]>>();\n        for(int i = 0; i < edges.length; i++) {\n            int[] edge = edges[i];\n            // System.out.println(\"\" + edge[0] + \", \" + edge[1]);\n            ArrayList<double[]> lst = neighbors.getOrDefault(edge[0], new ArrayList<double[]>());\n            double[] pair = {edge[1], -Math.log(succProb[i])};\n            lst.add(pair);\n            neighbors.put(edge[0], lst);\n\n            ArrayList<double[]> lst2 = neighbors.getOrDefault(edge[1], new ArrayList<double[]>());\n            double[] pair2 = {edge[0], -Math.log(succProb[i])};\n            lst2.add(pair2);\n            neighbors.put(edge[1], lst2);\n        }\n\n        HashMap<Integer, Double> distMap = new HashMap<Integer, Double>();\n        distMap.put(start, 0.0);\n        PriorityQueue<double[]> pq = new PriorityQueue<double[]>(\n            new Comparator<double[]>() {\n                @Override\n                public int compare(double[] pair1, double[] pair2) {\n                    return Double.valueOf(pair1[1]).compareTo(Double.valueOf(pair2[1]));\n                }\n            }\n        );\n        double[] initPair = {start, 0};\n        pq.add(initPair);\n        for(int i = 0; i < n; i++) {\n            if(i != start) {\n                distMap.put(i, Double.MAX_VALUE);\n            }\n        }\n        while(!pq.isEmpty()) {\n            double[] pair = pq.poll();\n            int node = (int) pair[0];\n            // System.out.println(\"node: \" + node);\n            if(node == end) return Math.exp(-distMap.get(end));\n            if(neighbors.get(node) == null) return 0;\n            for(double[] neighborPair : neighbors.get(node)) {\n                double alt = distMap.get(node) + neighborPair[1];\n                if(alt < distMap.get((int) neighborPair[0])) {\n                    distMap.put((int) neighborPair[0], alt);\n                    neighborPair[1] = alt;\n                    pq.add(neighborPair);\n                }\n            }\n        }\n        return 0;\n    }\n}","compare_result":"111111111111111111","title_slug":"path-with-maximum-probability","has_notes":false,"flag_type":1}